use builder::OofBuilder;
use context::*;
use core::fmt::{self, Debug, Display, Write};
use std::{
    any::TypeId,
    collections::HashSet,
    error::{self, Error},
};

// FEATURES:
// - attribute macros
// - oof!() like anyhow!()
//   - takes boolean value as optional first param. ex) oof!(list.is_empty(), "something")
// - oof_eq!()
// - suggestions?
// display_owned:
//   default: debug on and release off

mod builder;
mod chain;
mod context;
mod ext;
mod tsa;
mod util;

pub use ext::OofExt;
pub use oofs_derive::*;

pub mod used_by_attribute {
    pub use crate::{builder::*, context::*, ext::*, tsa::*, util::*};

    pub const DISPLAY_OWNED: bool = cfg!(any(
        all(debug_assertions, not(feature = "display_owned_disabled")),
        all(not(debug_assertions), feature = "display_owned_release")
    ));
}

#[macro_export]
macro_rules! oof {
    ($($arg:tt)*) => {
        oofs::Oof::from_message(format!($($arg)*))
    };
}

pub struct Oof {
    source: Option<Box<dyn 'static + Send + Sync + Error>>,
    message: OofMessage,
    context: Option<String>,
    location: Option<Location>,
    tags: HashSet<TypeId>,
}

impl Display for Oof {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            write!(f, "{:#}", &self.message)?;

            if let Some(context) = &self.context {
                write!(f, " with context `{context}`")?;
            }

            if let Some(location) = &self.location {
                write!(f, " at `{location}`")?;
            }

            for cause in chain::Chain::new(self).skip(1) {
                write!(f, ": {:#}", cause)?;
            }
        } else {
            write!(f, "{:}", &self.message)?;

            let mut indented = Indented {
                inner: f,
                number: None,
                started: false,
            };

            if let Some(context) = &self.context {
                write!(indented, "\nwith context `{context}`")?;
            }

            if let Some(location) = &self.location {
                write!(indented, "\nat `{location}`")?;
            }

            if let OofMessage::FnContext(c) = &self.message {
                c.write_params(f)?;
            }
        }

        Ok(())
    }
}

impl Debug for Oof {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            return f
                .debug_struct("Oof")
                .field("message", &self.message)
                .field("source", &self.source)
                .finish();
        }

        Display::fmt(&self, f)?;

        if let Some(cause) = self.source() {
            write!(f, "\n\nCaused by:")?;

            let multiple = cause.source().is_some();
            for (n, error) in chain::Chain::new(cause).enumerate() {
                writeln!(f)?;

                let mut indented = Indented {
                    inner: f,
                    number: if multiple { Some(n) } else { None },
                    started: false,
                };

                writeln!(indented, "{}", error)?;
            }
        }

        Ok(())
    }
}

impl error::Error for Oof {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        if let Some(e) = &self.source {
            Some(e.as_ref())
        } else {
            None
        }
    }
}

impl Oof {
    pub fn from_message<T: Into<OofMessage>>(message: T) -> Oof {
        Self::builder(message).build()
    }

    pub fn builder<T: Into<OofMessage>>(message: T) -> OofBuilder {
        OofBuilder::new(message.into())
    }

    pub fn tag<T: 'static>(&mut self) {
        self.tags.insert(TypeId::of::<T>());
    }

    pub fn tags(&self) -> impl Iterator<Item = &TypeId> {
        self.tags.iter()
    }

    pub fn tagged<T: 'static>(&self) -> bool {
        self.tags.contains(&TypeId::of::<T>())
    }

    pub fn tagged_nested<T: 'static>(&self) -> bool {
        if self.tagged::<T>() {
            return true;
        }

        for cause in chain::Chain::new(self).skip(1) {
            if let Some(e) = cause.downcast_ref::<Oof>() {
                if e.tagged::<T>() {
                    return true;
                }
            }
        }

        false
    }

    pub fn tagged_nested_rev<T: 'static>(&self) -> bool {
        for cause in chain::Chain::new(self).rev() {
            if let Some(e) = cause.downcast_ref::<Oof>() {
                if e.tagged::<T>() {
                    return true;
                }
            }
        }

        false
    }
}

#[cfg(test)]
mod tests {
    use super::{tsa::*, used_by_attribute::DISPLAY_OWNED, util::*, *};

    #[test]
    fn test_debug_ref() {
        let x = "hello world".to_owned();

        // These values are the expanded lines the attribute macro
        let __x_var_name = "self"; // generated by attribute macro
        let __x_type = x.__type_name();
        let __x_bin = __TsaBin(&x);
        let __x_ref_type = __x_bin.__ref_type();
        let __x_fn = __x_bin.__try_lazy_fn(true, |v| v.__try_debug());
        let __x_unloaded = __x_bin.__tsa_unload();

        let __parse_fn_name = "parse"; // generated by attribute macro
        let __parse_fn_is_async = true;

        let err = __x_unloaded
            .parse::<u64>()
            .map_err(|e| {
                let fn_param = FnArg::new(
                    VarType::var(__x_var_name),
                    __x_ref_type,
                    __x_type,
                    __x_fn.call(),
                );

                let fn_context =
                    FnContext::new(__parse_fn_is_async, __parse_fn_name, vec![fn_param]);

                OofBuilder::new(fn_context.into()).with_source(e)
            })
            .map_err(|b| b.build())
            .unwrap_err();

        println!("[ERROR] {err:?}");
    }

    #[test]
    fn test_debug_owned() {
        let x = "hello world".to_owned();

        // These values are the expanded lines the attribute macro
        let __x_var_name = "self"; // generated by attribute macro
        let __x_type = x.__type_name();
        let __x_bin = __TsaBin(x);
        let __x_ref_type = __x_bin.__ref_type();
        let __x_fn = __x_bin.__try_lazy_fn(true, |v| v.__try_debug());
        let __x_unloaded = __x_bin.__tsa_unload();

        let __parse_fn_name = "parse"; // generated by attribute macro
        let __parse_fn_is_async = true;

        let err = __x_unloaded
            .parse::<u64>()
            .map_err(|e| {
                let fn_param = FnArg::new(
                    VarType::var(__x_var_name),
                    __x_ref_type,
                    __x_type,
                    __x_fn.call(),
                );

                let fn_context =
                    FnContext::new(__parse_fn_is_async, __parse_fn_name, vec![fn_param]);

                OofBuilder::new(fn_context.into()).with_source(e)
            })
            .map_err(|b| b.build())
            .unwrap_err();

        println!("[ERROR] {err:?}");
    }

    #[test]
    fn test_return_from_tag() {
        pub struct MyTag;

        let x = "hello world".to_owned();

        // ===== These values are the expanded lines the attribute macro
        let __parse_fn_name = "parse"; // generated by attribute macro

        // whether or not the method is async; look for `.await` keyword.
        let __parse_fn_is_async = false;

        // default is false unless `.display_owned()` is called.
        let __parse_fn_display_owned = false || DISPLAY_OWNED;

        let __x_var_name = "self"; // generated by attribute macro
        let __x_type = x.__type_name();
        let __x_bin = __TsaBin(x);
        let __x_ref_type = __x_bin.__ref_type();
        let __x_fn = __x_bin.__try_lazy_fn(__parse_fn_display_owned, |v| v.__try_debug());
        let __x_unloaded = __x_bin.__tsa_unload();

        let err = __x_unloaded
            .parse::<u64>()
            .map_err(|e| {
                let fn_param = FnArg::new(
                    VarType::var(__x_var_name),
                    __x_ref_type,
                    __x_type,
                    __x_fn.call(),
                );

                let fn_context =
                    FnContext::new(__parse_fn_is_async, __parse_fn_name, vec![fn_param]);

                OofBuilder::new(fn_context.into()).with_source(e)
            })
            .tag::<MyTag>()
            .add_context(|| "example context".to_owned())
            .map_err(|b| b.build()) // not needed in actual code
            .unwrap_err();

        println!("[ERROR] {err:?}");
    }
}
